	

import org.apache.xpath.XPathAPI; import org.bouncycastle.jce.provider.BouncyCastleProvider; import org.globus.gsi.CertUtil; import org.globus.gsi.bc.BouncyCastleOpenSSLKey; import org.w3c.dom.Document; import org.w3c.dom.Node; import javax.xml.crypto.dsig.*; import javax.xml.crypto.dsig.dom.DOMSignContext; import javax.xml.crypto.dsig.keyinfo.KeyInfo; import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory; import javax.xml.crypto.dsig.keyinfo.KeyValue; import javax.xml.crypto.dsig.keyinfo.X509Data; import javax.xml.crypto.dsig.spec.XPathFilter2ParameterSpec; import javax.xml.crypto.dsig.spec.XPathType; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import java.io.BufferedInputStream; import java.io.File; import java.io.FileInputStream; import java.security.KeyPair; import java.security.Provider; import java.security.Security; import java.security.cert.X509Certificate; import java.util.ArrayList; import java.util.Collections; public class Test { static { if (Security.getProvider("BC") == null) Security.insertProviderAt(new BouncyCastleProvider(), 0); } public static void main(final String[] args) throws Exception { final BouncyCastleOpenSSLKey key = new BouncyCastleOpenSSLKey(new BufferedInputStream(new FileInputStream(args[1]))); key.decrypt(args[2]); final X509Certificate cert = CertUtil.loadCertificate(new BufferedInputStream(new FileInputStream(args[0]))); final KeyPair kp = new KeyPair(cert.getPublicKey(), key.getPrivateKey()); final String providerName = System.getProperty ("jsr105Provider", "org.jcp.xml.dsig.internal.dom.XMLDSigRI"); final XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM", (Provider) Class.forName(providerName).newInstance()); /* final ArrayList transList = new ArrayList(); final ArrayList xpathList = new ArrayList(); xpathList.add(new XPathType("/book/book[1]", XPathType.Filter.UNION)); transList.add(fac.newTransform(Transform.XPATH, new XPathFilterParameterSpec("/books/book[1]"))); transList.add(fac.newTransform(Transform.ENVELOPED, null)); final Reference ref = fac.newReference("", fac.newDigestMethod(DigestMethod.SHA1, null), transList, null, null); */ XPathFilter2ParameterSpec spec = new XPathFilter2ParameterSpec(Collections.singletonList(new XPathType("//book[2]", XPathType.Filter.INTERSECT))); final ArrayList refList = new ArrayList(); refList.add(fac.newTransform(Transform.ENVELOPED, null)); refList.add(fac.newTransform(Transform.XPATH2, spec)); final Reference ref = fac.newReference("", fac.newDigestMethod(DigestMethod.SHA1, null), refList, null, null); final SignedInfo si = fac.newSignedInfo(fac.newCanonicalizationMethod(CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS, null), fac.newSignatureMethod(SignatureMethod.RSA_SHA1, null), Collections.singletonList(ref)); // Create a KeyValue containing the DSA PublicKey that was generated final KeyInfoFactory kif = fac.getKeyInfoFactory(); final KeyValue kv = kif.newKeyValue(kp.getPublic()); final X509Data xdata = kif.newX509Data(Collections.singletonList(cert.getSubjectX500Principal().getName())); final ArrayList kiList = new ArrayList(); kiList.add(kv); kiList.add(xdata); // Create a KeyInfo and add the KeyValue to it final KeyInfo ki = kif.newKeyInfo(kiList); // Create the XMLSignature (but don't sign it yet) final XMLSignature signature = fac.newXMLSignature(si, ki); // Create the Document that will hold the resulting XMLSignature final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setNamespaceAware(true); // must be set final Document doc = dbf.newDocumentBuilder().parse(new File("Test.xml")); // Create a DOMSignContext and set the signing Key to the DSA // PrivateKey and specify where the XMLSignature should be inserted // in the target document (in this case, the document root); final Node node = XPathAPI.selectSingleNode(doc, "/books/book[2]"); final DOMSignContext signContext = new DOMSignContext(kp.getPrivate(), node); // Marshal, generate (and sign) the detached XMLSignature. The DOM // Document will contain the XML Signature if this method returns // successfully. signature.sign(signContext); final TransformerFactory tf = TransformerFactory.newInstance(); final Transformer trans = tf.newTransformer(); trans.transform(new DOMSource(doc), new StreamResult(System.out)); } } 